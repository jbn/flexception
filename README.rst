.. image:: https://img.shields.io/pypi/v/flexception.svg
        :target: https://pypi.python.org/pypi/flexception
.. image:: https://img.shields.io/travis/jbn/flexception.svg
        :target: https://travis-ci.org/jbn/flexception
.. image:: https://ci.appveyor.com/api/projects/status/7o14w2ro2lx6tr02?svg=true 
        :target: https://ci.appveyor.com/project/jbn/flexception/branch/master 
.. image:: https://coveralls.io/repos/github/jbn/flexception/badge.svg?branch=master
        :target: https://coveralls.io/github/jbn/flexception?branch=master


============
flexceptions
============

--------------------
Tryable Computations
--------------------

Messy data frustrate iterative development. Mike Bostock used this gif to 
illustrate the difficulty of debugging. Tryable computations (semi-cribbed 
from Scala's `Try`) wraps your computation in a structure that allows 
subsequent inspection.

This is useful in data cleaning / munging because you usually find yourself 
bewildered by idiosyncratic violations to reasonable expectations. You correct
for the edge case, and create two more failures. It's usually easier to 
collect many failures rather than aborting upon the first one.

---------------------
Exceptions for humans
---------------------

Stack traces are bad. Seriously, they are. Ever debug Spark stack traces. 
Just, awful. Ever debug Keras? EASY! (See post.) Flexceptions move the 
exception object to an inspectable instrument for iterative and interactive 
programming.

* Transformer hooks
* Traceback rewriting
* Display hooks
* Autogenerated fixtures / pytests
* Futures interface?
* https://github.com/Qix-/better-exceptions


~~~~~~~~~~~~~~~~~~~~~~~~~~~
A Note on Traceback Objects
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Traceback objects are not picklable. Projects like 
`tblib <https://pypi.org/project/tblib/>`_ provide *some* pickling support, at
the expense of some stripped traceback object properties -- notably, variables.
`samplebias <https://stackoverflow.com/users/538718/samplebias>`_ provided this
`excellent explanation to stackoverflow question <https://stackoverflow.com/questions/6132469/why-cant-i-pickle-an-errors-traceback-in-python>`_,

    The traceback holds references to the stack frames of each function/method
    that was called on the current thread, from the topmost-frame on down to 
    the point where the error was raised. Each stack frame also holds 
    references to the local and global variables in effect at the time each 
    function in the stack was called.
    
    Since there is no way for pickle to know what to serialize and what to 
    ignore, if you were able to pickle a traceback you'd end up pickling a 
    moving snapshot of the entire application state: as pickle runs, other 
    threads may be modifying the values of shared variables.
    
    One solution is to create a picklable object to walk the traceback and 
    extract only the information you need to save.
